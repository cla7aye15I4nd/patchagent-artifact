diff --git a/include/gpac/bitstream.h b/include/gpac/bitstream.h
index a1d439a71..ee7436b4c 100644
--- a/include/gpac/bitstream.h
+++ b/include/gpac/bitstream.h
@@ -624,6 +624,26 @@ Gets the current cookie on the bitstream
  */
 u64 gf_bs_get_cookie(GF_BitStream *bs);
 
+
+/*!
+\brief Marks overflow access
+
+Marks the bitstream as overflown (reading outside of buffer range). Marking is done automatically when reading but can be forced using this function.
+
+\param bs the target bitstream
+\param reset if GF_TRUE, reset overflown state, otherwise mark as overflown
+ */
+void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset);
+
+/*!
+\brief Gets overflow state
+
+Gets overflow state of the bitstream
+\param bs the target bitstream
+\return 2 if an overflow was marked by user using \ref gf_bs_mark_overflow, 1 if an overflow occured, 0 otherwise
+ */
+u32 gf_bs_is_overflow(GF_BitStream *bs);
+
 /*! @} */
 
 #ifdef __cplusplus
diff --git a/include/gpac/internal/media_dev.h b/include/gpac/internal/media_dev.h
index c1e20b011..c2c2833db 100644
--- a/include/gpac/internal/media_dev.h
+++ b/include/gpac/internal/media_dev.h
@@ -897,7 +897,7 @@ typedef struct
 	Bool mem_mode;
 	/*bitstream object for mem mode - this bitstream is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */
 	GF_BitStream *bs;
-	Bool bs_overread, unframed;
+	Bool unframed;
 	u8 *frame_obus;
 	u32 frame_obus_alloc;
 
diff --git a/src/filters/bs_agg.c b/src/filters/bs_agg.c
index 13edde450..e29077169 100644
--- a/src/filters/bs_agg.c
+++ b/src/filters/bs_agg.c
@@ -440,10 +440,12 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
 {
 	u32 size, pck_size, i, count, tot_size=0, nb_done=0;
 	u64 min_dts = GF_FILTER_NO_TS;
-	u32 min_timescale;
+	u32 min_timescale, min_nal_size;
 	GF_Err process_error = GF_OK;
 	Bool has_svc_prefix = GF_FALSE;
 
+	min_nal_size = codec_type ? 2 : 1;
+
 	count = gf_list_count(pctx->ipids);
 	for (i=0; i<count; i++) {
 		u64 ts;
@@ -517,11 +519,21 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
 				e = GF_NON_COMPLIANT_BITSTREAM;
 				break;
 			}
+			if (nal_size < min_nal_size) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSAgg] Invalid NAL size %d but mn size %d\n", nal_size, min_nal_size));
+				e = GF_NON_COMPLIANT_BITSTREAM;
+				break;
+			}
 
 			//AVC
 			if (codec_type==0) {
 				nal_type = data[size] & 0x1F;
 				if ((nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {
+					if (nal_size < 4) {
+						GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSAgg] Invalid NAL size %d but mn size 4\n", nal_size));
+						e = GF_NON_COMPLIANT_BITSTREAM;
+						break;
+					}
 					has_svc_prefix = GF_TRUE;
 					//quick parse svc nal header (right after 1-byte nal header)
 					//u32 prio_id = (data[size+1]) & 0x3F;
diff --git a/src/filters/bs_split.c b/src/filters/bs_split.c
index d8713ceeb..7dba22b84 100644
--- a/src/filters/bs_split.c
+++ b/src/filters/bs_split.c
@@ -1014,7 +1014,7 @@ static GF_Err none_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 
 static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacket *pck, u32 codec_type)
 {
-	u32 size, pck_size;
+	u32 size, pck_size, min_nal_size;
 	GF_Err e;
 	u64 pck_ts;
 	Bool has_svc_prefix = GF_FALSE;
@@ -1034,6 +1034,7 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 	if (!pctx->first_ts_plus_one) {
 		pctx->first_ts_plus_one = pck_ts+1;
 	}
+	min_nal_size = codec_type ? 2 : 1;
 
 	size=0;
 	while (size<pck_size) {
@@ -1055,6 +1056,11 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 			e = GF_NON_COMPLIANT_BITSTREAM;
 			break;
 		}
+		if (nal_size < min_nal_size) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSSplit] Invalid NAL size %d but mn size %d\n", nal_size, min_nal_size));
+			e = GF_NON_COMPLIANT_BITSTREAM;
+			break;
+		}
 
 		//AVC
 		if (codec_type==0) {
diff --git a/src/filters/inspect.c b/src/filters/inspect.c
index 6512a6a66..6e106fd45 100644
--- a/src/filters/inspect.c
+++ b/src/filters/inspect.c
@@ -575,7 +575,7 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 	if (hevc) {
 #ifndef GPAC_DISABLE_HEVC
 
-		if (ptr_size==1) {
+		if (ptr_size<=1) {
 			gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
 			return;
 		}
@@ -863,6 +863,11 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 	if (vvc) {
 		u8 lid, tid;
 
+		if (ptr_size<=1) {
+			gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
+			return;
+		}
+
 		if (full_bs_dump) {
 			vvc->parse_mode = 2;
 			if (pctx) {
@@ -1015,6 +1020,10 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 	}
 
 	//avc
+	if (!ptr_size) {
+		gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
+		return;
+	}
 	type = ptr[0] & 0x1F;
 	nal_ref_idc = ptr[0] & 0x60;
 	nal_ref_idc>>=5;
diff --git a/src/filters/reframe_nalu.c b/src/filters/reframe_nalu.c
index 5354c19a0..f5e050f72 100644
--- a/src/filters/reframe_nalu.c
+++ b/src/filters/reframe_nalu.c
@@ -2159,6 +2159,8 @@ static s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 	u8 nal_unit_type, temporal_id, layer_id;
 	*skip_nal = GF_FALSE;
 
+	if (size<2) return -1;
+
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	res = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);
 	ctx->nb_nalus++;
@@ -2333,6 +2335,7 @@ static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 	u8 nal_unit_type, temporal_id, layer_id;
 	*skip_nal = GF_FALSE;
 
+	if (size<2) return -1;
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	res = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);
 	ctx->nb_nalus++;
@@ -2510,6 +2513,7 @@ static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 n
 	s32 ps_idx = 0;
 	s32 res = 0;
 
+	if (!size) return -1;
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	*skip_nal = GF_FALSE;
 	res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);
diff --git a/src/isomedia/avc_ext.c b/src/isomedia/avc_ext.c
index bfe6ee7c0..da6b06317 100644
--- a/src/isomedia/avc_ext.c
+++ b/src/isomedia/avc_ext.c
@@ -2746,6 +2746,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
 	else
 		is_avcc = GF_FALSE;
 
+	//we don't use gf_odf_avc_cfg_read to deal with missing rext profile signaling on many files
 	ptr->config->configurationVersion = gf_bs_read_u8(bs);
 	ptr->config->AVCProfileIndication = gf_bs_read_u8(bs);
 	ptr->config->profile_compatibility = gf_bs_read_u8(bs);
@@ -2820,7 +2821,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
 			}
 		}
 #endif
-		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("AVCC: invalid syntax for REXT profile, patching.\n"));
+		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[isom/avcc] Missing REXT profile signaling, patching.\n"));
 		return GF_OK;
 	}
 	ISOM_DECREASE_SIZE(ptr, 4)
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index e66b1a2e0..0daae2752 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -1921,6 +1921,8 @@ GF_Err gf_vp9_parse_superframe(GF_BitStream *bs, u64 ivf_frame_size, u32 *num_fr
 	e = gf_bs_seek(bs, pos + ivf_frame_size - 1);
 	if (e) return e;
 
+	gf_bs_mark_overflow(bs, GF_TRUE);
+
 	byte = gf_bs_read_u8(bs);
 	if ((byte & 0xe0) != 0xc0)
 		goto exit; /*no superframe*/
@@ -1943,6 +1945,9 @@ GF_Err gf_vp9_parse_superframe(GF_BitStream *bs, u64 ivf_frame_size, u32 *num_fr
 
 exit:
 	gf_bs_seek(bs, pos);
+
+	if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
+
 	return e;
 }
 
@@ -2690,7 +2695,7 @@ GF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state
 	u64 tusize, sz;
 	if (!bs || !state) return GF_BAD_PARAM;
 
-	state->bs_overread = GF_FALSE;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 	tusize = sz = gf_av1_leb128_read(bs, NULL);
 	tupos = gf_bs_get_position(bs);
 	if (!sz) {
@@ -2703,7 +2708,7 @@ GF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state
 		u8 Leb128Bytes = 0;
 		u64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);
 
-		if (state->bs_overread) {
+		if (gf_bs_is_overflow(bs)) {
 			return GF_BUFFER_TOO_SMALL;
 		}
 		if (sz < Leb128Bytes + frame_unit_size) {
@@ -2716,7 +2721,7 @@ GF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state
 		while (frame_unit_size > 0) {
 			u64 pos, obu_size = gf_av1_leb128_read(bs, &Leb128Bytes);
 
-			if (state->bs_overread) {
+			if (gf_bs_is_overflow(bs)) {
 				return GF_BUFFER_TOO_SMALL;
 			}
 			if (frame_unit_size < Leb128Bytes + obu_size) {
@@ -4120,12 +4125,6 @@ static GF_Err av1_parse_frame(GF_BitStream *bs, AV1State *state, u64 obu_start,
 	return av1_parse_tile_group(bs, state, obu_start, obu_size);
 }
 
-static void on_aom_av1_eos(void *_state)
-{
-	AV1State *state = (AV1State *)_state;
-	state->bs_overread = GF_TRUE;
-}
-
 static void av1_parse_obu_metadata(AV1State *state, GF_BitStream *bs)
 {
 	u32 metadata_type = (u32)gf_av1_leb128_read(bs, NULL);
@@ -4156,13 +4155,13 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 	if (!bs || !obu_type || !state)
 		return GF_BAD_PARAM;
 
-	state->bs_overread = GF_FALSE;
-	gf_bs_set_eos_callback(bs, on_aom_av1_eos, state);
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	state->obu_extension_flag = state->obu_has_size_field = 0;
 	state->temporal_id = state->spatial_id = 0;
 	state->frame_state.uncompressed_header_bytes = 0;
 	e = gf_av1_parse_obu_header(bs, obu_type, &state->obu_extension_flag, &state->obu_has_size_field, &state->temporal_id, &state->spatial_id);
+	if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
 	if (e)
 		return e;
 
@@ -4180,7 +4179,7 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 		}
 	}
 	hdr_size = (u32)(gf_bs_get_position(bs) - pos);
-	if ((gf_bs_available(bs) < *obu_size) || state->bs_overread) {
+	if (gf_bs_is_overflow(bs) || (gf_bs_available(bs) < *obu_size) ) {
 		gf_bs_seek(bs, pos);
 		return GF_BUFFER_TOO_SMALL;
 	}
@@ -4210,7 +4209,7 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 	switch (*obu_type) {
 	case OBU_SEQUENCE_HEADER:
 		av1_parse_sequence_header_obu(bs, state);
-		if (gf_bs_get_position(bs) > pos + *obu_size) {
+		if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Sequence header parsing consumed too many bytes !\n"));
 			e = GF_NON_COMPLIANT_BITSTREAM;
 		}
@@ -4220,13 +4219,14 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 	case OBU_METADATA:
 		av1_parse_obu_metadata(state, bs);
 		gf_bs_seek(bs, pos + *obu_size);
+		if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
 		break;
 
 	case OBU_FRAME_HEADER:
 	case OBU_REDUNDANT_FRAME_HEADER:
 		if (state->config) {
 			av1_parse_frame_header(bs, state);
-			if (gf_bs_get_position(bs) > pos + *obu_size) {
+			if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Frame header parsing consumed too many bytes !\n"));
 				e = GF_NON_COMPLIANT_BITSTREAM;
 			}
@@ -4235,7 +4235,7 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 		break;
 	case OBU_FRAME:
 		e = av1_parse_frame(bs, state, pos, *obu_size);
-		if (gf_bs_get_position(bs) != pos + *obu_size) {
+		if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Frame parsing did not consume the right number of bytes !\n"));
 			e = GF_NON_COMPLIANT_BITSTREAM;
 		}
@@ -4244,7 +4244,7 @@ GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32
 	case OBU_TILE_GROUP:
 		if (state->config) {
 			e = av1_parse_tile_group(bs, state, pos, *obu_size);
-			if (gf_bs_get_position(bs) != pos + *obu_size) {
+			if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Tile group parsing did not consume the right number of bytes !\n"));
 				e = GF_NON_COMPLIANT_BITSTREAM;
 			}
@@ -4733,12 +4733,15 @@ u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 id
 	}
 
 	if (nb_lead>=32) {
-		//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
-		//we only test once nb_lead>=32 to avoid testing at each bit read
-		if (!gf_bs_available(bs)) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] exp-golomb read failed, not enough bits in bitstream !\n"));
-		} else {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n", nb_lead));
+		if (gf_bs_is_overflow(bs)<2) {
+			//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
+			//we only test once nb_lead>=32 to avoid testing at each bit read
+			if (!gf_bs_available(bs)) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] exp-golomb read failed, not enough bits in bitstream !\n"));
+			} else {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n", nb_lead));
+			}
+			gf_bs_mark_overflow(bs, GF_FALSE);
 		}
 		return 0;
 	}
@@ -6095,6 +6098,8 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 	AVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (!gf_bs_available(bs)) return -1;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	nal_hdr = gf_bs_read_u8(bs);
 
@@ -6114,6 +6119,8 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 
 	case GF_AVC_NALU_SVC_SLICE:
 		SVC_ReadNal_header_extension(bs, &n_state.svc_nalhdr);
+		if (gf_bs_is_overflow(bs)) return -1;
+
 		// slice buffer - read the info and compare.
 		/*ret = */svc_parse_slice(bs, avc, &n_state);
 		if (avc->s_info.nal_ref_idc) {
@@ -6131,6 +6138,7 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 
 	case GF_AVC_NALU_SVC_PREFIX_NALU:
 		SVC_ReadNal_header_extension(bs, &avc->s_info.svc_nalhdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		return 0;
 
 	case GF_AVC_NALU_IDR_SLICE:
@@ -6141,6 +6149,7 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 		slice = 1;
 		/* slice buffer - read the info and compare.*/
 		ret = avc_parse_slice(bs, avc, idr_flag, &n_state);
+		if (gf_bs_is_overflow(bs)) ret = -1;
 		if (ret < 0) return ret;
 		ret = 0;
 		if (
@@ -6202,19 +6211,23 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 		break;
 	case GF_AVC_NALU_SEQ_PARAM:
 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 
 	case GF_AVC_NALU_PIC_PARAM:
 		avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 	case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 	case GF_AVC_NALU_SEQ_PARAM_EXT:
 		avc->last_ps_idx = (s32) gf_bs_read_ue(bs);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 
@@ -8562,6 +8575,9 @@ s32 gf_hevc_parse_nalu_bs(GF_BitStream *bs, HEVCState *hevc, u8 *nal_unit_type,
 	HEVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (gf_bs_available(bs)<2) return -1;
+
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	memcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));
 	if (!hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;
@@ -8629,6 +8645,9 @@ s32 gf_hevc_parse_nalu_bs(GF_BitStream *bs, HEVCState *hevc, u8 *nal_unit_type,
 		break;
 	}
 
+	if (gf_bs_is_overflow(bs))
+		ret = -1;
+
 	/* save _prev values */
 	if ((ret>0) && hevc->s_info.sps) {
 		n_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;
@@ -8651,6 +8670,8 @@ s32 gf_hevc_parse_nalu(u8 *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u
 	GF_BitStream *bs = NULL;
 	s32 ret = -1;
 
+	if (size<2) return -1;
+
 	if (!hevc) {
 		if (nal_unit_type) (*nal_unit_type) = (data[0] & 0x7E) >> 1;
 		if (layer_id) {
@@ -11236,6 +11257,8 @@ s32 gf_vvc_parse_nalu_bs(GF_BitStream *bs, VVCState *vvc, u8 *nal_unit_type, u8
 	VVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (gf_bs_available(bs)<2) return -1;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	memcpy(&n_state, &vvc->s_info, sizeof(VVCSliceInfo));
 	if (!vvc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;
@@ -11322,6 +11345,7 @@ s32 gf_vvc_parse_nalu_bs(GF_BitStream *bs, VVCState *vvc, u8 *nal_unit_type, u8
 		ret = 0;
 		break;
 	}
+	if (gf_bs_is_overflow(bs)) ret = -1;
 
 	/* save current POC lsb/msb to prev values */
 	if ((ret>0) && vvc->s_info.sps) {
@@ -11344,6 +11368,8 @@ s32 gf_vvc_parse_nalu(u8 *data, u32 size, VVCState *vvc, u8 *nal_unit_type, u8 *
 	GF_BitStream *bs = NULL;
 	s32 ret;
 
+	if (size<2) return -1;
+
 	if (!vvc) {
 		if (nal_unit_type) (*nal_unit_type) = data[1] >> 3;
 		if (layer_id) (*layer_id) = data[0] & 0x3f;
diff --git a/src/odf/descriptors.c b/src/odf/descriptors.c
index 8b4bf1817..0c2143c48 100644
--- a/src/odf/descriptors.c
+++ b/src/odf/descriptors.c
@@ -2,7 +2,7 @@
  *			GPAC - Multimedia Framework C SDK
  *
  *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
+ *			Copyright (c) Telecom ParisTech 2000-2022
  *					All rights reserved
  *
  *  This file is part of GPAC / MPEG-4 ObjectDescriptor sub-project
@@ -601,17 +601,47 @@ GF_AVCConfig *gf_odf_avc_cfg_read(u8 *dsi, u32 dsi_size)
 	gf_bs_read_int(bs, 3);
 	count = gf_bs_read_int(bs, 5);
 	for (i=0; i<count; i++) {
-		GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-		sl->size = gf_bs_read_int(bs, 16);
+		GF_NALUFFParam *sl;
+		u32 size = gf_bs_read_int(bs, 16);
+		if ((size>gf_bs_available(bs)) || (size<2)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		GF_SAFEALLOC(sl, GF_NALUFFParam );
+		if (!sl) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		sl->size = size;
 		sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+		if (!sl->data) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(avcc->sequenceParameterSets, sl);
 	}
 	count = gf_bs_read_int(bs, 8);
 	for (i=0; i<count; i++) {
-		GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-		sl->size = gf_bs_read_int(bs, 16);
+		GF_NALUFFParam *sl;
+		u32 size = gf_bs_read_int(bs, 16);
+		if ((size>gf_bs_available(bs)) || (size<2)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		GF_SAFEALLOC(sl, GF_NALUFFParam );
+		if (!sl) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		sl->size = size;
 		sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+		if (!sl->data) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(avcc->pictureParameterSets, sl);
 	}
@@ -627,9 +657,24 @@ GF_AVCConfig *gf_odf_avc_cfg_read(u8 *dsi, u32 dsi_size)
 		if (count) {
 			avcc->sequenceParameterSetExtensions = gf_list_new();
 			for (i=0; i<count; i++) {
-				GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-				sl->size = gf_bs_read_u16(bs);
-				sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
+				GF_NALUFFParam *sl;
+				u32 size = gf_bs_read_int(bs, 16);
+				if ((size>gf_bs_available(bs)) || (size<2)) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
+				GF_SAFEALLOC(sl, GF_NALUFFParam );
+				if (!sl) {
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
+				sl->size = size;
+				sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+				if (!sl->data) {
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
 				gf_bs_read_data(bs, sl->data, sl->size);
 				gf_list_add(avcc->sequenceParameterSetExtensions, sl);
 			}
@@ -1050,7 +1095,7 @@ GF_HEVCConfig *gf_odf_hevc_cfg_read_bs(GF_BitStream *bs, Bool is_lhvc)
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl;
 			u32 size = gf_bs_read_int(bs, 16);
-			if (size>gf_bs_available(bs)) {
+			if ((size>gf_bs_available(bs)) || (size<2)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[HEVC] Wrong param set size %d\n", size));
 				gf_odf_hevc_cfg_del(cfg);
 				return NULL;
@@ -1330,7 +1375,7 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl;
 			u32 size = gf_bs_read_int(bs, 16);
-			if (size>gf_bs_available(bs)) {
+			if ((size>gf_bs_available(bs)) || (size<2)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] Wrong param set size %d\n", size));
 				gf_odf_vvc_cfg_del(cfg);
 				return NULL;
diff --git a/src/utils/bitstream.c b/src/utils/bitstream.c
index dd235db17..6ea644ca1 100644
--- a/src/utils/bitstream.c
+++ b/src/utils/bitstream.c
@@ -77,6 +77,7 @@ struct __tag_bitstream
 	void *log_udta;
 
 	u32 total_bits_read;
+	u32 overflow_state;
 };
 
 GF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)
@@ -355,6 +356,7 @@ static u8 BS_ReadByte(GF_BitStream *bs)
 		u8 res;
 		if (bs->position >= bs->size) {
 			if (bs->EndOfStream) bs->EndOfStream(bs->par);
+			if (!bs->overflow_state) bs->overflow_state = 1;
 			return 0;
 		}
 		res = bs->original[bs->position++];
@@ -404,6 +406,7 @@ static u8 BS_ReadByte(GF_BitStream *bs)
 bs_eof:
 	if (bs->EndOfStream) {
 		bs->EndOfStream(bs->par);
+		if (!bs->overflow_state) bs->overflow_state = 1;
 	} else {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[BS] Attempt to overread bitstream\n"));
 	}
@@ -613,6 +616,7 @@ u64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)
 		if (gf_bs_available(bs) * 8 < nBits-8) {
 			if (bs->EndOfStream) bs->EndOfStream(bs->par);
 			bs->position = bs->size;
+			if (!bs->overflow_state) bs->overflow_state = 1;
 			return 0;
 		}
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("Reading %d bits but max should be 64, skipping %d most significants bits\n", nBits, nBits-64));
@@ -1324,6 +1328,7 @@ static GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)
 GF_EXPORT
 GF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)
 {
+	bs->overflow_state = 0;
 	if (bs->on_block_out) {
 		GF_Err e;
 		if (offset < bs->bytes_out) {
@@ -1706,3 +1711,11 @@ void gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32
 #endif
 
 
+void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)
+{
+	bs->overflow_state = reset ? 0 : 2;
+}
+u32 gf_bs_is_overflow(GF_BitStream *bs)
+{
+	return bs->overflow_state;
+}
